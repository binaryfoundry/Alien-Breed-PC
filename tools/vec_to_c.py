#!/usr/bin/env python3
"""
Parse Amiga .vec (or .vec.s) vector object files and emit C-friendly output.

Usage:
  python tools/vec_to_c.py [--input PATH] [--output PATH] [--name NAME] [--dump]
  python tools/vec_to_c.py --input data/vectorobjects/robot.vec --output src/vec_robot.c --name robot

Reads binary .vec or assembly .vec.s (dc.b $XX,$YY lines). With --output writes
a .c file with static const uint8_t array and size (same layout as .vec so
runtime can parse via docs/vec_format.md). With --dump prints parsed summary
(num_points, num_frames, parts, polygons) to stderr.

See docs/vec_format.md for the .vec binary layout.
"""

from pathlib import Path
import re
import struct
import sys
import argparse


def read_vec_bytes(path: Path) -> bytes:
    """Load .vec as bytes: from binary file or by parsing .vec.s dc.b lines."""
    data = path.read_bytes()
    if path.suffix.lower() == ".s" or path.name.lower().endswith(".vec.s"):
        return _parse_vec_s(data)
    return data


def _parse_vec_s(data: bytes) -> bytes:
    """Extract byte stream from assembly dc.b $XX,$YY lines. Returns bytes."""
    out = []
    # Match dc.b $XX,$YY or dc.b $XX (single byte) with optional comment
    for line in data.splitlines():
        line = line.decode("latin-1").strip()
        if not line or line.startswith(";"):
            continue
        # Find all $HH hex bytes on this line
        for m in re.finditer(r"\$([0-9A-Fa-f]{2})", line):
            out.append(int(m.group(1), 16))
    return bytes(out)


def read_be16(data: bytes, offset: int) -> int:
    if offset + 2 > len(data):
        raise ValueError(f"offset {offset} + 2 > len {len(data)}")
    return struct.unpack_from(">H", data, offset)[0]


def read_be16_signed(data: bytes, offset: int) -> int:
    if offset + 2 > len(data):
        raise ValueError(f"offset {offset} + 2 > len {len(data)}")
    return struct.unpack_from(">h", data, offset)[0]


def parse_vec_summary(data: bytes) -> dict:
    """Parse .vec header and part list; return summary and validate."""
    if len(data) < 6:
        raise ValueError("vec too short for header")
    num_points = read_be16(data, 0)
    num_frames = read_be16(data, 2)
    if num_frames == 0:
        raise ValueError("num_frames is 0")
    frame_offsets = [read_be16(data, 4 + 2 * i) for i in range(num_frames)]
    part_list_start = 4 + 2 * num_frames
    parts = []
    pos = part_list_start
    while pos + 4 <= len(data):
        part_offs = read_be16_signed(data, pos)  # Amiga: blt doneallparts
        sort_pt = read_be16(data, pos + 2)
        if part_offs < 0:
            break
        parts.append({"offset": part_offs, "sort_point": sort_pt})
        pos += 4
    return {
        "num_points": num_points,
        "num_frames": num_frames,
        "frame_offsets": frame_offsets,
        "parts": parts,
        "part_list_end": pos,
    }


def count_part_polygons(data: bytes, part_offset: int) -> int:
    """Count polygon records in one part (until lines_to_draw < 0)."""
    n = 0
    pos = part_offset
    while pos + 2 <= len(data):
        lines = read_be16_signed(data, pos)
        if lines < 0:
            break
        n += 1
        pos += 18 + lines * 4
    return n


def dump_summary(data: bytes, name: str) -> None:
    s = parse_vec_summary(data)
    poly_count = sum(count_part_polygons(data, p["offset"]) for p in s["parts"])
    print(
        f"[vec] {name}: points={s['num_points']} frames={s['num_frames']} "
        f"parts={len(s['parts'])} polygons={poly_count}",
        file=sys.stderr,
    )


def emit_c_array(path: Path, data: bytes, c_name: str) -> str:
    """Emit C source with static const uint8_t array and size."""
    lines = [
        "/* Generated by tools/vec_to_c.py. Do not edit. */",
        "#include <stdint.h>",
        "",
        f"static const uint8_t {c_name}_data[] = {{",
    ]
    for i in range(0, len(data), 12):
        chunk = data[i : i + 12]
        hexs = ", ".join(f"0x{b:02x}" for b in chunk)
        lines.append(f"  {hexs},")
    lines.append("};")
    lines.append("")
    lines.append(f"static const unsigned int {c_name}_size = {len(data)}u;")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    ap = argparse.ArgumentParser(description="Convert .vec / .vec.s to C data")
    ap.add_argument("--input", "-i", type=Path, default=None, help="Input .vec or .vec.s file")
    ap.add_argument("--output", "-o", type=Path, default=None, help="Output .c file")
    ap.add_argument("--name", "-n", type=str, default=None, help="C array base name (default from input stem)")
    ap.add_argument("--dump", action="store_true", help="Print parsed summary to stderr")
    args = ap.parse_args()

    repo = Path(__file__).resolve().parent.parent
    data_dir = repo / "data" / "vectorobjects"
    if args.input is None:
        # Default: first .vec or .vec.s in data/vectorobjects
        if not data_dir.is_dir():
            print(f"Error: not a directory: {data_dir}", file=sys.stderr)
            return 1
        candidates = list(data_dir.glob("*.vec")) + list(data_dir.glob("*.vec.s")) + list(data_dir.glob("*.s"))
        if not candidates:
            print(f"Error: no .vec or .vec.s in {data_dir}", file=sys.stderr)
            return 1
        args.input = candidates[0]
    if not args.input.is_file():
        print(f"Error: file not found: {args.input}", file=sys.stderr)
        return 1
    name = args.name or args.input.stem
    if name.lower().endswith(".vec"):
        name = name[:-4]

    try:
        data = read_vec_bytes(args.input)
    except Exception as e:
        print(f"Error reading {args.input}: {e}", file=sys.stderr)
        return 1
    if len(data) < 6:
        print("Error: file too short", file=sys.stderr)
        return 1

    try:
        parse_vec_summary(data)
    except ValueError as e:
        print(f"Error parsing .vec: {e}", file=sys.stderr)
        return 1

    if args.dump:
        dump_summary(data, name)

    c_name = "vec_" + name.replace("-", "_").replace(".", "_")
    if args.output:
        args.output.write_text(emit_c_array(args.output, data, c_name), encoding="utf-8")
        print(f"Wrote {args.output} ({len(data)} bytes, symbol {c_name}_data / {c_name}_size)", file=sys.stderr)
    else:
        print(emit_c_array(args.input, data, c_name))

    return 0


if __name__ == "__main__":
    sys.exit(main())
