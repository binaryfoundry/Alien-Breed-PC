#!/usr/bin/env python3
"""
Convert .pal files in data/pal to C tables in src/sprite_palettes_data.h.
Run from repo root:  python tools/pal_to_header.py
No runtime .pal loading; palettes are embedded in the header.
"""
from pathlib import Path
import sys

# Order matches MAX_SPRITE_TYPES and stub_io sprite_pal_names (index -> filename, any case)
PAL_FILES = [
    "alien2.pal", "PICKUPS.PAL", "bigbullet.pal", "uglymonster.pal",
    "FLYINGalien.pal", "keys.pal", "ROCKETS.pal", "BARREL.pal",
    "explosion.pal", "newgunsinhand.pal", "newmarine.pal", "BIGSCARYALIEN.pal",
    "LAMPS.pal", "worm.pal", "bigclaws.pal", "tree.pal",
    "toughmutant.pal", "flamemutant.pal",
]
MAX_SPRITE_TYPES = 20


def find_pal(pal_dir: Path, name: str) -> Path | None:
    stem = Path(name).stem.lower()
    for f in pal_dir.iterdir():
        if f.suffix.lower() == ".pal" and f.stem.lower() == stem:
            return f
    p = pal_dir / name
    if p.exists():
        return p
    return None


def main() -> int:
    repo = Path(__file__).resolve().parent.parent
    pal_dir = repo / "data" / "pal"
    out_header = repo / "src" / "sprite_palettes_data.h"

    if not pal_dir.is_dir():
        print(f"Error: directory not found: {pal_dir}", file=sys.stderr)
        return 1

    # Collect (index, bytes) for each .pal found
    pal_data: list[tuple[int, bytes]] = []
    for i in range(min(len(PAL_FILES), MAX_SPRITE_TYPES)):
        name = PAL_FILES[i]
        if not name.lower().endswith(".pal"):
            name = name + ".pal"
        path = find_pal(pal_dir, name)
        if path:
            data = path.read_bytes()
            if len(data) >= 64:
                pal_data.append((i, data))
            else:
                print(f"Warning: skip {path.name} (size {len(data)} < 64)", file=sys.stderr)
        else:
            print(f"Warning: not found: {name}", file=sys.stderr)

    if not pal_data:
        print("Error: no valid .pal files in " + str(pal_dir), file=sys.stderr)
        return 1

    # Build per-index arrays
    array_names: list[str] = []
    sizes: list[int] = [0] * MAX_SPRITE_TYPES
    for i in range(MAX_SPRITE_TYPES):
        entry = next((p for p in pal_data if p[0] == i), None)
        if entry:
            array_names.append(f"sprite_pal_{i}")
            sizes[i] = len(entry[1])
        else:
            array_names.append("")

    lines = [
        "/* Generated by tools/pal_to_header.py from data/pal/*.pal. Do not edit. */",
        "#ifndef SPRITE_PALETTES_DATA_H",
        "#define SPRITE_PALETTES_DATA_H",
        "#include <stddef.h>",
        "#include <stdint.h>",
        "",
    ]

    for i, (name, size) in enumerate(zip(array_names, sizes)):
        if not name or size == 0:
            continue
        _, data = next(p for p in pal_data if p[0] == i)
        lines.append(f"static const uint8_t {name}[{size}] = {{")
        for j in range(0, len(data), 16):
            chunk = data[j : j + 16]
            hexs = ", ".join(f"0x{b:02x}u" for b in chunk)
            lines.append(f"  {hexs},")
        lines.append("};")
        lines.append("")

    lines.append("/* MAX_SPRITE_TYPES from renderer.h (include order: renderer.h then this) */")
    lines.append("")
    lines.append("const uint8_t *sprite_pal_embedded[MAX_SPRITE_TYPES] = {")
    for i in range(MAX_SPRITE_TYPES):
        if array_names[i]:
            lines.append(f"  {array_names[i]},")
        else:
            lines.append("  NULL,")
    lines.append("};")
    lines.append("")
    lines.append("const size_t sprite_pal_embedded_size[MAX_SPRITE_TYPES] = {")
    for i in range(MAX_SPRITE_TYPES):
        lines.append(f"  {sizes[i]}u,")
    lines.append("};")
    lines.append("")
    lines.append("#endif")

    out_header.parent.mkdir(parents=True, exist_ok=True)
    out_header.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"Wrote {len(pal_data)} palette(s) to {out_header}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
